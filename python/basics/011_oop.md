# üöó 011: Object-Oriented Programming (OOP)

OOP lets you organize code by bundling data (attributes) and behavior (methods) into objects. Classes are blueprints; objects are instances. OOP enables encapsulation, abstraction, reusability, and inheritance‚Äîmaking large programs easier to manage, extend, and maintain.

## üéØ Python OOP: Practical, Tricky, and Fun Usages

```python
# ===== 1. Basic Class & Object Creation =====
class Dog:
    def __init__(self, name, age, breed):
        self.name = name
        self.age = age
        self.breed = breed
    def bark(self):
        print(f"{self.name} says: Woof!")
    def birthday(self):
        self.age += 1
        print(f"Happy Birthday, {self.name}! Now {self.age}.")

dog1 = Dog("Rex", 5, "German Shepherd")
dog2 = Dog("Buddy", 2, "Golden Retriever")
dog1.bark()
dog2.birthday()
print(dog1.name, dog2.breed)

# ===== 2. Class vs Instance Attributes =====
class Car:
    wheels = 4  # class attribute
    def __init__(self, make):
        self.make = make  # instance attribute
car1 = Car("Ford")
car2 = Car("Toyota")
print(car1.wheels, car2.make)

# ===== 3. Methods, Static, Class Methods =====
class Math:
    @staticmethod
    def add(a, b):
        return a + b
    @classmethod
    def info(cls):
        print(f"This is {cls.__name__}")
print(Math.add(2, 3))
Math.info()

# ===== 4. Inheritance & Super =====
class Animal:
    def speak(self):
        print("Animal sound")
class Cat(Animal):
    def speak(self):
        super().speak()
        print("Meow!")
cat = Cat()
cat.speak()

# ===== 5. Encapsulation & Name Mangling =====
class Secret:
    def __init__(self):
        self._hidden = "protected"
        self.__private = "private"
    def reveal(self):
        print(self._hidden)
secret = Secret()
secret.reveal()
# print(secret.__private)  # ‚ùå AttributeError
print(secret._Secret__private)  # Name mangling

# ===== 6. Properties & Getters/Setters =====
class Person:
    def __init__(self, age):
        self._age = age
    @property
    def age(self):
        return self._age
    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("Age must be positive")
        self._age = value
person = Person(30)
print(person.age)
person.age = 40

# ===== 7. Magic/Dunder Methods =====
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __str__(self):
        return f"({self.x}, {self.y})"
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
p1 = Point(1, 2)
p2 = Point(3, 4)
print(p1 + p2)

# ===== 8. Class Inheritance Tree & isinstance =====
print(isinstance(cat, Animal), issubclass(Cat, Animal))

# ===== 9. Fun Tricks & Advanced Usages =====
class Counter:
    count = 0
    def __init__(self):
        Counter.count += 1
    @classmethod
    def total(cls):
        return cls.count
c1 = Counter()
c2 = Counter()
print(Counter.total())

# ===== 10. Common Pitfalls =====
class MutableDefault:
    def __init__(self, data=[]):
        self.data = data
    def add(self, value):
        self.data.append(value)
md1 = MutableDefault()
md2 = MutableDefault()
md1.add(1)
md2.add(2)
print(md1.data, md2.data)  # Both share the same list!

# ===== 11. Multiple Inheritance =====
class A:
    def foo(self): print("A")
class B:
    def foo(self): print("B")
class C(A, B): pass
c = C()
c.foo()  # MRO: A first

# ===== 12. Fun with __call__ =====
class Greeter:
    def __call__(self, name):
        print(f"Hi, {name}!")
g = Greeter()
g("Python")

# ===== 13. Class as First-Class Citizens =====
def apply_class(cls, *args):
    return cls(*args)
print(apply_class(Point, 7, 8))
```
